# ConfigMap para scripts de backup
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-backup-scripts
  namespace: redis
data:
  backup.sh: |
    #!/bin/bash
    set -e
    
    BACKUP_DIR="/backup"
    TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
    BACKUP_FILE="redis_backup_${TIMESTAMP}.rdb"
    BACKUP_PATH="${BACKUP_DIR}/${BACKUP_FILE}"
    
    echo "Iniciando backup Redis em $(date)"
    
    # Criar diretório de backup se não existir
    mkdir -p "$BACKUP_DIR"
    
    # Fazer backup do master
    echo "Fazendo backup do Redis Master..."
    redis-cli --tls \
      --cert /tls/tls.crt \
      --key /tls/tls.key \
      --cacert /tls/ca.crt \
      -h redis-master.redis.svc.cluster.local -p 6380 \
      -a "$REDIS_PASSWORD" \
      --rdb "$BACKUP_PATH"
    
    if [ $? -eq 0 ]; then
      echo "Backup criado com sucesso: $BACKUP_PATH"
      
      # Comprimir backup
      gzip "$BACKUP_PATH"
      COMPRESSED_FILE="${BACKUP_PATH}.gz"
      
      echo "Backup comprimido: $COMPRESSED_FILE"
      
      # Verificar integridade do backup
      if [ -f "$COMPRESSED_FILE" ]; then
        SIZE=$(stat -c%s "$COMPRESSED_FILE")
        echo "Tamanho do backup: $SIZE bytes"
        
        # Manter apenas os últimos 7 backups
        echo "Limpando backups antigos..."
        find "$BACKUP_DIR" -name "redis_backup_*.rdb.gz" -type f -mtime +7 -delete
        
        echo "Backup concluído com sucesso em $(date)"
      else
        echo "ERRO: Arquivo de backup não encontrado após compressão"
        exit 1
      fi
    else
      echo "ERRO: Falha ao criar backup"
      exit 1
    fi
  
  restore.sh: |
    #!/bin/bash
    set -e
    
    if [ -z "$1" ]; then
      echo "Uso: $0 <arquivo_backup.rdb.gz>"
      echo "Backups disponíveis:"
      ls -la /backup/redis_backup_*.rdb.gz 2>/dev/null || echo "Nenhum backup encontrado"
      exit 1
    fi
    
    BACKUP_FILE="$1"
    RESTORE_FILE="/tmp/restore.rdb"
    
    echo "Iniciando restauração do backup: $BACKUP_FILE"
    
    # Verificar se arquivo existe
    if [ ! -f "$BACKUP_FILE" ]; then
      echo "ERRO: Arquivo de backup não encontrado: $BACKUP_FILE"
      exit 1
    fi
    
    # Descomprimir backup
    echo "Descomprimindo backup..."
    gunzip -c "$BACKUP_FILE" > "$RESTORE_FILE"
    
    # Parar replicação temporariamente
    echo "Pausando replicação..."
    for i in 0 1 2; do
      redis-cli --tls \
        --cert /tls/tls.crt \
        --key /tls/tls.key \
        --cacert /tls/ca.crt \
        -h redis-replica-$i.redis-replica-headless.redis.svc.cluster.local -p 6380 \
        -a "$REDIS_PASSWORD" \
        REPLICAOF NO ONE || true
    done
    
    # Fazer flush do master antes da restauração
    echo "Limpando dados atuais do master..."
    redis-cli --tls \
      --cert /tls/tls.crt \
      --key /tls/tls.key \
      --cacert /tls/ca.crt \
      -h redis-master.redis.svc.cluster.local -p 6380 \
      -a "$REDIS_PASSWORD" \
      FLUSHALL
    
    # Restaurar dados (isso requer acesso ao filesystem do pod)
    echo "AVISO: A restauração completa requer acesso direto ao filesystem do pod Redis"
    echo "Execute os seguintes comandos manualmente:"
    echo "1. kubectl cp $RESTORE_FILE redis/redis-master-0:/data/dump.rdb"
    echo "2. kubectl exec -it redis-master-0 -n redis -- redis-cli -a \$REDIS_PASSWORD DEBUG RESTART"
    
    # Reconfigurar replicação
    echo "Reconfigurando replicação..."
    sleep 10
    for i in 0 1 2; do
      redis-cli --tls \
        --cert /tls/tls.crt \
        --key /tls/tls.key \
        --cacert /tls/ca.crt \
        -h redis-replica-$i.redis-replica-headless.redis.svc.cluster.local -p 6380 \
        -a "$REDIS_PASSWORD" \
        REPLICAOF redis-master.redis.svc.cluster.local 6380
    done
    
    echo "Processo de restauração iniciado. Verifique os logs dos pods para confirmar."
    
    # Limpar arquivo temporário
    rm -f "$RESTORE_FILE"
---
# PersistentVolumeClaim para armazenar backups
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: redis-backup-storage
  namespace: redis
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 50Gi
  storageClassName: microk8s-hostpath
---
# CronJob para backup automático
apiVersion: batch/v1
kind: CronJob
metadata:
  name: redis-backup
  namespace: redis
  labels:
    app: redis-backup
spec:
  # Executar backup diariamente às 2:00 AM
  schedule: "0 2 * * *"
  timeZone: "America/Sao_Paulo"
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 1
  jobTemplate:
    spec:
      template:
        metadata:
          labels:
            app: redis-backup
        spec:
          restartPolicy: OnFailure
          serviceAccountName: redis-operator
          containers:
          - name: redis-backup
            image: redis:7-alpine
            env:
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: redis-auth
                  key: REDIS_PASSWORD
            volumeMounts:
            - name: backup-storage
              mountPath: /backup
            - name: backup-scripts
              mountPath: /scripts
            - name: tls-certs
              mountPath: /tls
              readOnly: true
            command: ["/bin/sh"]
            args: ["/scripts/backup.sh"]
            resources:
              requests:
                memory: "256Mi"
                cpu: "100m"
              limits:
                memory: "512Mi"
                cpu: "500m"
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: redis-backup-storage
          - name: backup-scripts
            configMap:
              name: redis-backup-scripts
              defaultMode: 0755
          - name: tls-certs
            secret:
              secretName: redis-tls-secret
---
# Job para backup manual (pode ser executado sob demanda)
apiVersion: batch/v1
kind: Job
metadata:
  name: redis-manual-backup
  namespace: redis
  labels:
    app: redis-backup
    type: manual
spec:
  ttlSecondsAfterFinished: 3600
  template:
    metadata:
      labels:
        app: redis-backup
        type: manual
    spec:
      restartPolicy: OnFailure
      serviceAccountName: redis-operator
      containers:
      - name: redis-backup
        image: redis:7-alpine
        env:
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis-auth
              key: REDIS_PASSWORD
        volumeMounts:
        - name: backup-storage
          mountPath: /backup
        - name: backup-scripts
          mountPath: /scripts
        - name: tls-certs
          mountPath: /tls
          readOnly: true
        command: ["/bin/sh"]
        args: ["/scripts/backup.sh"]
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: backup-storage
        persistentVolumeClaim:
          claimName: redis-backup-storage
      - name: backup-scripts
        configMap:
          name: redis-backup-scripts
          defaultMode: 0755
      - name: tls-certs
        secret:
          secretName: redis-tls-secret