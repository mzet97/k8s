# PodDisruptionBudget para Redis Master
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: redis-master-pdb
  namespace: redis
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app: redis-master
      role: master
---
# PodDisruptionBudget para Redis Réplicas
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: redis-replica-pdb
  namespace: redis
spec:
  minAvailable: 2
  selector:
    matchLabels:
      app: redis-replica
      role: replica
---
# NetworkPolicy para Redis - Permitir tráfego interno
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: redis-network-policy
  namespace: redis
spec:
  podSelector:
    matchLabels:
      app: redis-master
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Permitir tráfego de réplicas para master
  - from:
    - podSelector:
        matchLabels:
          app: redis-replica
    ports:
    - protocol: TCP
      port: 6379
    - protocol: TCP
      port: 6380
  # Permitir tráfego de exporters
  - from:
    - podSelector:
        matchLabels:
          app: redis-exporter
    ports:
    - protocol: TCP
      port: 6379
    - protocol: TCP
      port: 6380
  # Permitir tráfego de jobs de backup e setup
  - from:
    - podSelector:
        matchLabels:
          app: redis-backup
    - podSelector:
        matchLabels:
          app: redis-setup
    ports:
    - protocol: TCP
      port: 6379
    - protocol: TCP
      port: 6380
  # Permitir tráfego de aplicações no namespace
  - from:
    - namespaceSelector:
        matchLabels:
          name: redis
    ports:
    - protocol: TCP
      port: 6379
    - protocol: TCP
      port: 6380
  egress:
  # Permitir DNS
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
  # Permitir comunicação com Kubernetes API
  - to: []
    ports:
    - protocol: TCP
      port: 443
---
# NetworkPolicy para Redis Réplicas
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: redis-replica-network-policy
  namespace: redis
spec:
  podSelector:
    matchLabels:
      app: redis-replica
  policyTypes:
  - Ingress
  - Egress
  ingress:
  # Permitir tráfego de exporters
  - from:
    - podSelector:
        matchLabels:
          app: redis-exporter
    ports:
    - protocol: TCP
      port: 6379
    - protocol: TCP
      port: 6380
  # Permitir tráfego de aplicações no namespace
  - from:
    - namespaceSelector:
        matchLabels:
          name: redis
    ports:
    - protocol: TCP
      port: 6379
    - protocol: TCP
      port: 6380
  egress:
  # Permitir comunicação com master
  - to:
    - podSelector:
        matchLabels:
          app: redis-master
    ports:
    - protocol: TCP
      port: 6379
    - protocol: TCP
      port: 6380
  # Permitir DNS
  - to: []
    ports:
    - protocol: UDP
      port: 53
    - protocol: TCP
      port: 53
  # Permitir comunicação com Kubernetes API
  - to: []
    ports:
    - protocol: TCP
      port: 443
---
# HorizontalPodAutoscaler para Redis Exporter Replica
# Comentado temporariamente até resolver problemas de métricas
# Para habilitar, descomente após verificar que o metrics-server está funcionando
# e que o deployment redis-exporter-replica está rodando corretamente
#
# apiVersion: autoscaling/v2
# kind: HorizontalPodAutoscaler
# metadata:
#   name: redis-exporter-replica-hpa
#   namespace: redis
# spec:
#   scaleTargetRef:
#     apiVersion: apps/v1
#     kind: Deployment
#     name: redis-exporter-replica
#   minReplicas: 2
#   maxReplicas: 4
#   metrics:
#   - type: Resource
#     resource:
#       name: cpu
#       target:
#         type: Utilization
#         averageUtilization: 70
#   - type: Resource
#     resource:
#       name: memory
#       target:
#         type: Utilization
#         averageUtilization: 80
#   behavior:
#     scaleDown:
#       stabilizationWindowSeconds: 300
#       policies:
#       - type: Percent
#         value: 10
#         periodSeconds: 60
#     scaleUp:
#       stabilizationWindowSeconds: 60
#       policies:
#       - type: Percent
#         value: 50
#         periodSeconds: 60
---
# ConfigMap para scripts de failover
apiVersion: v1
kind: ConfigMap
metadata:
  name: redis-failover-scripts
  namespace: redis
data:
  check-master.sh: |
    #!/bin/bash
    set -e
    
    MASTER_HOST="redis-master.redis.svc.cluster.local"
    MASTER_PORT="6380"
    
    echo "Verificando status do Redis Master..."
    
    # Verificar se master está respondendo
    if redis-cli --tls \
      --cert /tls/tls.crt \
      --key /tls/tls.key \
      --cacert /tls/ca.crt \
      -h "$MASTER_HOST" -p "$MASTER_PORT" \
      -a "$REDIS_PASSWORD" \
      ping | grep -q PONG; then
      echo "Master está saudável"
      exit 0
    else
      echo "ERRO: Master não está respondendo"
      exit 1
    fi
  
  promote-replica.sh: |
    #!/bin/bash
    set -e
    
    if [ -z "$1" ]; then
      echo "Uso: $0 <replica-number>"
      echo "Exemplo: $0 0"
      exit 1
    fi
    
    REPLICA_NUM="$1"
    REPLICA_HOST="redis-replica-${REPLICA_NUM}.redis-replica-headless.redis.svc.cluster.local"
    REPLICA_PORT="6380"
    
    echo "Promovendo réplica $REPLICA_NUM para master..."
    
    # Promover réplica para master
    redis-cli --tls \
      --cert /tls/tls.crt \
      --key /tls/tls.key \
      --cacert /tls/ca.crt \
      -h "$REPLICA_HOST" -p "$REPLICA_PORT" \
      -a "$REDIS_PASSWORD" \
      REPLICAOF NO ONE
    
    if [ $? -eq 0 ]; then
      echo "Réplica $REPLICA_NUM promovida com sucesso!"
      
      # Reconfigurar outras réplicas
      for i in 0 1 2; do
        if [ "$i" != "$REPLICA_NUM" ]; then
          echo "Reconfigurando réplica $i..."
          redis-cli --tls \
            --cert /tls/tls.crt \
            --key /tls/tls.key \
            --cacert /tls/ca.crt \
            -h "redis-replica-$i.redis-replica-headless.redis.svc.cluster.local" -p "$REPLICA_PORT" \
            -a "$REDIS_PASSWORD" \
            REPLICAOF "$REPLICA_HOST" "$REPLICA_PORT" || true
        fi
      done
      
      echo "Failover concluído com sucesso!"
    else
      echo "ERRO: Falha ao promover réplica $REPLICA_NUM"
      exit 1
    fi
  
  health-check.sh: |
    #!/bin/bash
    set -e
    
    echo "=== Health Check Redis Cluster ==="
    echo "Timestamp: $(date)"
    echo ""
    
    # Verificar master
    echo "Verificando Redis Master..."
    if redis-cli --tls \
      --cert /tls/tls.crt \
      --key /tls/tls.key \
      --cacert /tls/ca.crt \
      -h redis-master.redis.svc.cluster.local -p 6380 \
      -a "$REDIS_PASSWORD" \
      ping | grep -q PONG; then
      echo "✓ Master está saudável"
      
      # Obter informações de replicação do master
      echo "Informações de replicação do Master:"
      redis-cli --tls \
        --cert /tls/tls.crt \
        --key /tls/tls.key \
        --cacert /tls/ca.crt \
        -h redis-master.redis.svc.cluster.local -p 6380 \
        -a "$REDIS_PASSWORD" \
        INFO replication | grep -E "role:|connected_slaves:"
    else
      echo "✗ Master não está respondendo"
    fi
    
    echo ""
    
    # Verificar réplicas
    for i in 0 1 2; do
      echo "Verificando Redis Replica $i..."
      if redis-cli --tls \
        --cert /tls/tls.crt \
        --key /tls/tls.key \
        --cacert /tls/ca.crt \
        -h redis-replica-$i.redis-replica-headless.redis.svc.cluster.local -p 6380 \
        -a "$REDIS_PASSWORD" \
        ping | grep -q PONG; then
        echo "✓ Replica $i está saudável"
        
        # Verificar status de replicação
        REPL_STATUS=$(redis-cli --tls \
          --cert /tls/tls.crt \
          --key /tls/tls.key \
          --cacert /tls/ca.crt \
          -h redis-replica-$i.redis-replica-headless.redis.svc.cluster.local -p 6380 \
          -a "$REDIS_PASSWORD" \
          INFO replication | grep "master_link_status:" | cut -d: -f2 | tr -d '\r')
        
        if [ "$REPL_STATUS" = "up" ]; then
          echo "  ✓ Replicação ativa"
        else
          echo "  ✗ Replicação com problemas: $REPL_STATUS"
        fi
      else
        echo "✗ Replica $i não está respondendo"
      fi
    done
    
    echo ""
    echo "=== Fim do Health Check ==="
---
# CronJob para health check automático
apiVersion: batch/v1
kind: CronJob
metadata:
  name: redis-health-check
  namespace: redis
spec:
  schedule: "*/5 * * * *"  # A cada 5 minutos
  concurrencyPolicy: Forbid
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  jobTemplate:
    spec:
      template:
        spec:
          restartPolicy: OnFailure
          serviceAccountName: redis-operator
          containers:
          - name: health-check
            image: redis:7-alpine
            env:
            - name: REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: redis-auth
                  key: REDIS_PASSWORD
            volumeMounts:
            - name: scripts
              mountPath: /scripts
            - name: tls-certs
              mountPath: /tls
              readOnly: true
            command: ["/bin/sh"]
            args: ["/scripts/health-check.sh"]
            resources:
              requests:
                memory: "64Mi"
                cpu: "50m"
              limits:
                memory: "128Mi"
                cpu: "200m"
          volumes:
          - name: scripts
            configMap:
              name: redis-failover-scripts
              defaultMode: 0755
          - name: tls-certs
            secret:
              secretName: redis-tls-secret